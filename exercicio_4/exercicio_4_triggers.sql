'1) Crie uma tabela aluno com as colunas matrícula e nome.
Depois crie um trigger que não permita o cadastro de alunos
cujo nome começa com a letra “a”.'
	
CREATE TABLE ALUNO(
	MATRICULA INT PRIMARY KEY,
	NOME VARCHAR(30) NOT NULL
)

CREATE OR REPLACE FUNCTION INSERCAO_NEGADA()
RETURNS TRIGGER AS $$
BEGIN
	IF NEW.NOME ILIKE 'A%' THEN
		RAISE EXCEPTION 'O nome digitado não pode começar com a letra "a"';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER A_NAO BEFORE INSERT 
ON ALUNO FOR EACH ROW 
EXECUTE PROCEDURE INSERCAO_NEGADA()

INSERT INTO ALUNO VALUES(1, 'JOAO')
SELECT * FROM ALUNO
INSERT INTO ALUNO VALUES(2, 'ANDRE')

'2) Primeiro crie uma tabela chamada Funcionário com os
seguintes campos: código (int), nome (varchar(30)), salário
(int), data_última_atualização (timestamp),
usuário_que_atualizou (varchar(30)). Na inserção desta
tabela, você deve informar apenas o código, nome e salário do
funcionário. Agora crie um Trigger que não permita o nome
nulo, a salário nulo e nem negativo. Faça testes que
comprovem o funcionamento do Trigger.'
	
CREATE TABLE FUNCIONARIO(
	CODIGO INT PRIMARY KEY,
	NOME VARCHAR(30),
	SALARIO INT,
	DATA_ULTIMA_ATUALIZACAO TIMESTAMP,
	USER_QUE_ATUALIZOU VARCHAR(30)
)

CREATE OR REPLACE FUNCTION VERIFICA_NOME()
RETURNS TRIGGER AS $$
BEGIN
	IF NEW.NOME IS NULL THEN
		RAISE EXCEPTION 'O nome não pode ser nulo.';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER NOME_NAO_NULO BEFORE INSERT
ON FUNCIONARIO FOR EACH ROW
EXECUTE PROCEDURE VERIFICA_NOME()

CREATE OR REPLACE FUNCTION VERIFICA_SALARIO()
RETURNS TRIGGER AS $$
BEGIN
	IF NEW.SALARIO IS NULL OR NEW.SALARIO < 0 THEN
		RAISE EXCEPTION 'Valor inválido para o salário.';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER SALARIO_NAO_NULO BEFORE INSERT
ON FUNCIONARIO FOR EACH ROW
EXECUTE PROCEDURE VERIFICA_SALARIO()

CREATE OR REPLACE FUNCTION QUEM_QUANDO_ATUALIZOU()
RETURNS TRIGGER AS $$
BEGIN
	NEW.DATA_ULTIMA_ATUALIZACAO := NOW();
	NEW.USER_QUE_ATUALIZOU := current_user;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER ATUALIZACAO BEFORE UPDATE
ON FUNCIONARIO FOR EACH ROW
EXECUTE PROCEDURE QUEM_QUANDO_ATUALIZOU()

INSERT INTO FUNCIONARIO VALUES(1, 'ISRAEL', 990)
INSERT INTO FUNCIONARIO VALUES(2, 'ANDRE', 0)
INSERT INTO FUNCIONARIO VALUES(3, 'JONAS', -1)
INSERT INTO FUNCIONARIO (CODIGO, NOME, SALARIO) VALUES(2, NULL, 300)
	
UPDATE FUNCIONARIO 
SET SALARIO = 600
WHERE NOME LIKE 'ANDRE'

SELECT * FROM FUNCIONARIO

'3) Agora crie uma tabela chamada Empregado com os atributos
nome e salário. Crie também outra tabela chamada
Empregado_auditoria com os atributos: operação (char(1)),
usuário (varchar), data (timestamp), nome (varchar), salário
(integer) . Agora crie um trigger que registre na tabela
Empregado_auditoria a modificação que foi feita na tabela
empregado (E,A,I), quem fez a modificação, a data da
modificação, o nome do empregado que foi alterado e o salário
atual dele.'
	
CREATE TABLE EMPREGADO(
	COD SERIAL PRIMARY KEY,
	NOME VARCHAR(30),
	SALARIO INT
)

CREATE TABLE EMPREGADO_AUDITORIA(
	COD SERIAL PRIMARY KEY,
	OPERACAO CHAR(1),
	USUARIO VARCHAR(30),
	DATA_MODIFICACAO TIMESTAMP,
	NOME VARCHAR(30),
	SALARIO INT
)

CREATE OR REPLACE FUNCTION AUDITOR()
RETURNS TRIGGER AS $$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO EMPREGADO_AUDITORIA (OPERACAO, USUARIO, DATA_MODIFICACAO, NOME, SALARIO) VALUES(
			'I', current_user, now(), NEW.NOME, NEW.SALARIO
		);
	ELSIF TG_OP = 'UPDATE' THEN
		INSERT INTO EMPREGADO_AUDITORIA (OPERACAO, USUARIO, DATA_MODIFICACAO, NOME, SALARIO) VALUES(
			'U', current_user, now(), NEW.NOME, NEW.SALARIO
		);
	ELSIF TG_OP = 'DELETE' THEN
		INSERT INTO EMPREGADO_AUDITORIA (OPERACAO, USUARIO, DATA_MODIFICACAO, NOME, SALARIO) VALUES(
			'D', current_user, now(), OLD.NOME, OLD.SALARIO
		);
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER VERIFICACAO
AFTER INSERT OR UPDATE OR DELETE
ON EMPREGADO FOR EACH ROW
EXECUTE PROCEDURE AUDITOR()

INSERT INTO EMPREGADO (NOME, SALARIO) VALUES ('ISRAEL', 3500)

SELECT * FROM EMPREGADO_AUDITORIA

UPDATE EMPREGADO
SET SALARIO = 4000
WHERE NOME LIKE 'ISRAEL'

SELECT * FROM EMPREGADO_AUDITORIA

'4) Crie a tabela Empregado2 com os atributos código (serial e
chave primária), nome (varchar) e salário (integer). Crie
também a tabela Empregado2_audit com os seguintes
atributos: usuário (varchar), data (timestamp), id (integer),
coluna (text), valor_antigo (text), valor_novo(text). Agora crie
um trigger que não permita a alteração da chave primária e
insira registros na tabela Empregado2_audit para refletir as
alterações realizadas na tabela Empregado2.'
	
CREATE TABLE EMPREGADO2(
	COD SERIAL PRIMARY KEY,
	NOME VARCHAR(30),
	SALARIO INT
)

CREATE TABLE EMPREGADO2_AUDIT(
	USUARIO VARCHAR(30),
	DATA_MOD TIMESTAMP,
	COD INT,
	COLUNA TEXT,
	VALOR_ANTIGO TEXT,
	VALOR_NOVO TEXT
)

CREATE OR REPLACE FUNCTION PK_MOD()
RETURNS TRIGGER AS $$
BEGIN
	IF TG_OP = 'UPDATE' THEN
		IF NEW.COD <> OLD.COD THEN
			RAISE EXCEPTION 'A chave primária não pode ser modificada.';
		END IF;

		IF NEW.NOME <> OLD.NOME THEN
			INSERT INTO EMPREGADO2_AUDIT (USUARIO, DATA_MOD, COD, COLUNA, VALOR_ANTIGO, VALOR_NOVO) VALUES
			(CURRENT_USER, NOW(),NEW.COD, 'NOME', OLD.NOME::TEXT, NEW.NOME::TEXT);
		END IF;

		IF NEW.SALARIO <> OLD.SALARIO THEN
			INSERT INTO EMPREGADO2_AUDIT (USUARIO, DATA_MOD, COD, COLUNA, VALOR_ANTIGO, VALOR_NOVO) VALUES
			(CURRENT_USER, NOW(),NEW.COD, 'SALARIO', OLD.SALARIO::TEXT, NEW.SALARIO::TEXT);
		END IF;
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER ATUALIZACAO
AFTER UPDATE ON EMPREGADO2
FOR EACH ROW
EXECUTE PROCEDURE PK_MOD()

INSERT INTO EMPREGADO2 (NOME, SALARIO) VALUES('ISRAEL', 6000)
SELECT * FROM EMPREGADO2
UPDATE EMPREGADO2
SET SALARIO = 7000
WHERE NOME = 'ISRAEL'
SELECT * FROM EMPREGADO2_AUDIT
